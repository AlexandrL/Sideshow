<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\main.js - Sideshow</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://github.com/fortesinformatica/sideshow/examples/images/sideshow-logo.svg" title="Sideshow"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Arrow.html">Arrow</a></li>
            
                <li><a href="../classes/Arrows.html">Arrows</a></li>
            
                <li><a href="../classes/ControlVariables.html">ControlVariables</a></li>
            
                <li><a href="../classes/DetailsPanel.html">DetailsPanel</a></li>
            
                <li><a href="../classes/FadableItem.html">FadableItem</a></li>
            
                <li><a href="../classes/HidableItem.html">HidableItem</a></li>
            
                <li><a href="../classes/Mask.CloseButton.html">Mask.CloseButton</a></li>
            
                <li><a href="../classes/Mask.CompositeMask.html">Mask.CompositeMask</a></li>
            
                <li><a href="../classes/Mask.CornerPart.html">Mask.CornerPart</a></li>
            
                <li><a href="../classes/Mask.Part.html">Mask.Part</a></li>
            
                <li><a href="../classes/Mask.Polling.html">Mask.Polling</a></li>
            
                <li><a href="../classes/Mask.Subject.html">Mask.Subject</a></li>
            
                <li><a href="../classes/Mask.SubjectMask.html">Mask.SubjectMask</a></li>
            
                <li><a href="../classes/Mask.WizardMenu.html">Mask.WizardMenu</a></li>
            
                <li><a href="../classes/Screen.html">Screen</a></li>
            
                <li><a href="../classes/SS.html">SS</a></li>
            
                <li><a href="../classes/SSException.html">SSException</a></li>
            
                <li><a href="../classes/StepDescription.html">StepDescription</a></li>
            
                <li><a href="../classes/StepDescriptionNextButton.html">StepDescriptionNextButton</a></li>
            
                <li><a href="../classes/VisualItem.html">VisualItem</a></li>
            
                <li><a href="../classes/Wizard.html">Wizard</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\main.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//Just preventing the worst... =D 
//http://stackoverflow.com/questions/7365172/semicolon-before-self-invoking-function
;
(function(global, $, jazz, markdown) {
    //jQuery is needed
    if ($ === undefined) throw new SSException(&quot;2&quot;, &quot;jQuery is required for Sideshow to work.&quot;);

    //Jazz is needed
    if (jazz === undefined) throw new SSException(&quot;3&quot;, &quot;Jazz is required for Sideshow to work.&quot;);

    var globalObjectName = &quot;Sideshow&quot;,
        $body,
        pollingDuration = 200,
        longAnimationDuration = 600,

        /** 
        The main class for Sideshow

        @class SS 
        @static
        **/
        SS = {
            /**
            The current Sideshow version

            @property VERSION
            @type String
            **/
            get VERSION() {
                return &quot;0.3.3&quot;;
            }
        },

        controlVariables = [],
        flags = {
            lockMaskUpdate: false,
            changingStep: false,
            skippingStep: false,
            running: false
        },
        wizards = [],
        currentWizard,

        /**
        Possible statuses for an animation

        @@enum AnimationStatus
        **/
        AnimationStatus = jazz.Enum(&quot;VISIBLE&quot;, &quot;FADING_IN&quot;, &quot;FADING_OUT&quot;, &quot;NOT_DISPLAYED&quot;, &quot;NOT_RENDERED&quot;, &quot;TRANSPARENT&quot;);







    /**
    A custom exception class for Sideshow

    @class SSException
    @extends Error
    @param {String} code                                  The error code
    @param {String} message                               The error message
    **/
    function SSException(code, message) {
        this.name = &quot;SSException&quot;;
        this.message = &quot;[SIDESHOW_E#&quot; + (&quot;00000000&quot; + code).substr(-8) + &quot;] &quot; + message;
    }

    SSException.prototype = new Error();
    SSException.prototype.constructor = SSException;

    /**
    Shows a warning  in a pre-defined format

    @@function showWarning
    @param {String} code                                  The warning code
    @param {String} message                               The warning message
    **/
    function showWarning(code, message) {
        console.warn(&quot;[SIDESHOW_W#&quot; + (&quot;00000000&quot; + code).substr(-8) + &quot;] &quot; + message);
    }

    /**
    Parses a string in the format &quot;#px&quot; in a number

    @@function parsePxValue
    @param {String} value                                 A value with/without a px unit
    @return Number                                        The number value without unit 
    **/
    function parsePxValue(value) {
        if (value.constructor !== String) return value;
        var br = value === &quot;&quot; ? &quot;0&quot; : value;
        return +br.replace(&quot;px&quot;, &quot;&quot;);
    }







    /**
    Strings Dictionary

    @@object strings
    **/
    var strings = {
        availableWizards: {
            &quot;en&quot;: &quot;Available Tutorials&quot;,
            &quot;pt-br&quot;: &quot;Tutoriais Disponíveis&quot;
        },
        relatedWizards: {
            &quot;en&quot;: &quot;Related Wizards&quot;,
            &quot;pt-br&quot;: &quot;Tutoriais Relacionados&quot;
        },
        noAvailableWizards: {
            &quot;en&quot;: &quot;There&#x27;s no tutorials available.&quot;,
            &quot;pt-br&quot;: &quot;Não há tutoriais disponíveis para esta tela.&quot;
        },
        close: {
            &quot;en&quot;: &quot;Close&quot;,
            &quot;pt-br&quot;: &quot;Fechar&quot;
        },
        estimatedTime: {
            &quot;en&quot;: &quot;Estimated Time&quot;,
            &quot;pt-br&quot;: &quot;Tempo Estimado&quot;
        },
        next: {
            &quot;en&quot;: &quot;Next&quot;,
            &quot;pt-br&quot;: &quot;Continuar&quot;
        },
        finishWizard: {
            &quot;en&quot;: &quot;Finish Wizard&quot;,
            &quot;pt-br&quot;: &quot;Concluir Tutorial&quot;
        }
    };

    /**
    Gets a string from the dictionary in the current language

    @@function getString
    @param {Object} stringKeyValuePair                    A string key-value pair in dictionary
    @return String                                        The string value in the current language
    **/
    function getString(stringKeyValuePair) {
        if (!(SS.config.language in stringKeyValuePair)) {
            showWarning(&quot;2001&quot;, &quot;String not found for the selected language, getting the first available.&quot;);
            return stringKeyValuePair[Object.keys(stringKeyValuePair)[0]];
        }

        return stringKeyValuePair[SS.config.language];
    }







    /**
    Sideshow Settings

    @@object config
    **/
    SS.config = {};

    /**
    Application route to persists user preferences

    @@field userPreferencesRoute
    @type String
    @@unused
    @@todo Implement persistence logic
    **/
    SS.config.userPreferencesRoute = null;

    /**
    Logged in user

    @@field loggedInUser
    @type String
    @@unused
    **/
    SS.config.loggedInUser = null;

    /**
    Chosen language for sideshow interface

    @@field language
    @type String
    **/
    SS.config.language = &quot;en&quot;;







    /**
    Stores the variables used in step evaluators 

    @class ControlVariables
    @static
    **/
    SS.ControlVariables = {};

    /**
    Sets a variable value

    @method set
    @param {String} name                                  The variable name
    @param {String} value                                 The variable value
    @return {String}                                      A formatted key=value pair representing the defined variable 
    **/
    SS.ControlVariables.set = function(name, value) {
        var variable = {};
        if (this.isDefined(name)) {
            variable = this.getNameValuePair(name);
        } else controlVariables.push(variable);

        variable.name = name;
        variable.value = value;
        return name + &quot;=&quot; + value;
    };

    /**
    Sets a variable if not defined yet

    @method setIfUndefined
    @param {String} name                                  The variable name
    @param {String} value                                 The variable value
    @return {String}                                      A formatted key=value pair representing the defined variable 
    **/
    SS.ControlVariables.setIfUndefined = function(name, value) {
        if (!this.isDefined(name)) return this.set(name, value);
    };

    /**
    Checks if some variable is already defined

    @method isDefined
    @param {String} name                                  The variable name
    @return {boolean}                                     A boolean indicating if the variable is already defined
    **/
    SS.ControlVariables.isDefined = function(name) {
        return this.getNameValuePair(name) !== undefined;
    };

    /**
    Gets a variable value

    @method get
    @param {String} name                                  The variable name
    @return {any}                                         The variable value
    **/
    SS.ControlVariables.get = function(name) {
        var pair = this.getNameValuePair(name);
        return pair ? pair.value : undefined;
    };

    /**
    Gets a pair with name and value 

    @method getNameValuePair
    @param {String} name                                  The variable name
    @return {Object}                                      A pair with the variable name and value
    **/
    SS.ControlVariables.getNameValuePair = function(name) {
        for (var i = 0; i &lt; controlVariables.length; i++) {
            var variable = controlVariables[i];
            if (variable.name === name) return variable;
        }
    };

    /**
    Remove some variable from the control variables collection

    @method remove
    @param {String} name                                  The variable name
    @return {Object}                                      A pair with the removed variable name and value
    **/
    SS.ControlVariables.remove = function(name) {
        return controlVariables.splice(controlVariables.indexOf(this.getNameValuePair(name)), 1);
    };

    /**
    Clear the control variables collection 

    @method clear
    **/
    SS.ControlVariables.clear = function() {
        controlVariables = [];
    };







    /**
    A visual item 

    @class VisualItem
    @@abstract
    **/
    var VisualItem = jazz.Class().abstract;

    /**
    The jQuery wrapped DOM element for the visual item

    @@field $el
    @type Object 
    **/
    VisualItem.field(&quot;$el&quot;);

    /**
    The jQuery wrapped DOM element for the visual item

    @@field $el
    @type AnimationStatus 
    **/
    VisualItem.field(&quot;status&quot;, AnimationStatus.NOT_RENDERED);

    /**
    Renders the item&#x27;s DOM object

    @method render
    **/
    VisualItem.method(&quot;render&quot;, function($parent) {
        ($parent || $body).append(this.$el);
        this.status = AnimationStatus.NOT_DISPLAYED;
    });

    /**
    Destroys the item&#x27;s DOM object

    @method destroy
    **/
    VisualItem.method(&quot;destroy&quot;, function() {
        this.$el.remove();
    });







    /**
    A visual item which can be shown and hidden

    @class HidableItem
    @@abstract
    @extends VisualItem
    **/
    var HidableItem = jazz.Class().extending(VisualItem).abstract;

    /**
    Shows the visual item

    @method show
    @param {boolean} displayButKeepTransparent            The item will hold space but keep invisible
    **/
    HidableItem.method(&quot;show&quot;, function(displayButKeepTransparent) {
        if (!this.$el) this.render();
        if (!displayButKeepTransparent) this.$el.removeClass(&quot;sideshow-invisible&quot;);
        this.$el.removeClass(&quot;sideshow-hidden&quot;);
        this.status = AnimationStatus.VISIBLE;
    });

    /**
    Hides the visual item

    @method hide
    **/
    HidableItem.method(&quot;hide&quot;, function(keepHoldingSpace) {
        if (!keepHoldingSpace) this.$el.addClass(&quot;sideshow-hidden&quot;);
        this.$el.addClass(&quot;sideshow-invisible&quot;);
        this.status = AnimationStatus.NOT_DISPLAYED;
    });







    /**
    A visual item which holds fading in and out capabilities

    @class FadableItem
    @@abstract
    @extends HidableItem
    **/
    var FadableItem = jazz.Class().extending(HidableItem).abstract;

    /**
    Does a fade in transition for the visual item

    @method fadeIn
    **/
    FadableItem.method(&quot;fadeIn&quot;, function(callback, linearTimingFunction) {
        var item = this;
        item.status = AnimationStatus.FADING_IN;

        if (!item.$el) this.render();
        if (linearTimingFunction) item.$el.css(&quot;animation-timing-function&quot;, &quot;linear&quot;);
        item.$el.removeClass(&quot;sideshow-hidden&quot;);

        //Needed hack to get CSS transition to work properly
        setTimeout(function() {
            item.$el.removeClass(&quot;sideshow-invisible&quot;);

            setTimeout(function() {
                item.status = AnimationStatus.VISIBLE;
                if (linearTimingFunction) item.$el.css(&quot;animation-timing-function&quot;, &quot;ease&quot;);
                if (callback) callback();
            }, longAnimationDuration);
        }, 0); //&lt;-- Yeap, I&#x27;m really scheduling a timeout for 0 second... this is the dirty trick =)
    });

    /**
    Does a fade out transition for the visual item

    @method fadeOut
    **/
    FadableItem.method(&quot;fadeOut&quot;, function(callback, linearTimingFunction) {
        var item = this;
        if (item.status != AnimationStatus.NOT_RENDERED) {
            item.status = AnimationStatus.FADING_OUT;

            if (linearTimingFunction) item.$el.css(&quot;animation-timing-function&quot;, &quot;linear&quot;);
            item.$el.addClass(&quot;sideshow-invisible&quot;);

            setTimeout(function() {
                item.$el.addClass(&quot;sideshow-hidden&quot;);
                item.status = AnimationStatus.NOT_DISPLAYED;
                if (linearTimingFunction) item.$el.css(&quot;animation-timing-function&quot;, &quot;ease&quot;);
                if (callback) callback();
            }, longAnimationDuration);
        }
    });







    /**
    Represents a tutorial

    @class Wizard
    @@initializer
    @param {Object} wizardConfig                          The wizard configuration object                        
    **/
    var Wizard = jazz.Class(function(wizardConfig) {
        this.name = wizardConfig.name;
        this.title = wizardConfig.title;
        this.description = wizardConfig.description;
        this.estimatedTime = wizardConfig.estimatedTime;
        this.affects = wizardConfig.affects;
        this.preparation = wizardConfig.preparation;
        this.listeners = wizardConfig.listeners;
        this.showStepPosition = wizardConfig.showStepPosition;
        this.relatedWizards = wizardConfig.relatedWizards;
    });

    /**
    A function to prepare the environment for running a wizard (e.g. redirecting to some screen)

    @@field preparation
    @type Function
    **/
    Wizard.field(&quot;preparation&quot;);

    /**
    An object with listeners to this wizard (e.g. beforeWizardStarts, afterWizardEnds)

    @@field listeners
    @type Object
    **/
    Wizard.field(&quot;listeners&quot;);

    /**
    A configuration flag that defines if the step position (e.g. 2/10, 3/15, 12/12) will be shown

    @@field showStepPosition
    @type boolean
    **/
    Wizard.field(&quot;showStepPosition&quot;);

    /**
    An array with related wizards names. These wizards are listed after the ending of the current wizard.

    @@field relatedWizards
    @type Array
    **/
    Wizard.field(&quot;relatedWizards&quot;);

    /**
    The wizard unique name (used internally as an identifier)

    @@field name
    @type String
    **/
    Wizard.field(&quot;name&quot;);

    /**
    The wizard title (will be shown in the list of available wizards)

    @@field title
    @type String
    **/
    Wizard.field(&quot;title&quot;);

    /**
    The wizard description (will be shown in the list of available wizards)

    @@field description
    @type String
    **/
    Wizard.field(&quot;description&quot;);

    /**
    The wizard estimated completion time (will be shown in the list of available wizards)

    @@field estimatedTime
    @type String
    **/
    Wizard.field(&quot;estimatedTime&quot;);

    /**
    A collection of rules to infer whether a wizard should be available in a specific screen

    @@field affects
    @type Array
    **/
    Wizard.field(&quot;affects&quot;);

    /**
    The sequence of steps for this wizard

    @@field storyline
    @private
    @type Object
    **/
    Wizard.field(&quot;_storyline&quot;);

    /**
    Points to the current step object in a playing wizard

    @@field currentStep
    @type Object
    **/
    Wizard.field(&quot;currentStep&quot;);

    /**
    Sets the storyline for the wizard

    @method storyLine
    **/
    Wizard.method(&quot;storyLine&quot;, function(storyline) {
        this._storyline = storyline;
    });

    /**
    Runs the wizard

    @method play
    **/
    Wizard.method(&quot;play&quot;, function() {
        var wiz = this;

        Polling.enqueue(function() {
            Mask.CompositeMask.singleInstance.pollForChanges();
        });

        Polling.enqueue(function() {
            Arrows.pollForArrowsChanges();
        });

        //Checks if the wizard has a storyline
        if (!this._storyline) throw new SSException(&quot;201&quot;, &quot;A wizard needs to have a storyline.&quot;);
        var steps = this._storyline.steps;

        //Checks if the storyline has at least one step
        if (steps.length === 0) throw new SSException(&quot;202&quot;, &quot;A storyline must have at least one step.&quot;);

        DetailsPanel.singleInstance.render();

        StepDescription.singleInstance.render();

        var listeners = this.listeners;
        if (listeners &amp;&amp; listeners.beforeWizardStarts) listeners.beforeWizardStarts();

        flags.changingStep = true;
        this.showStep(steps[0], function() {
            //Releases the polling for checking any changes in the current subject
            flags.lockMaskUpdate = false;

            //Register the function that checks the completing of a step in the polling queue
            Polling.enqueue(function() {
                wiz.pollForCheckCompletedStep();
            });
        });

        Mask.CompositeMask.singleInstance.fadeIn();
    });

    /**
    Shows a specific step

    @method showStep
    @param {Object} step                                  The step to be shown
    @param {Function} callback                            A callback function to be called
    **/
    Wizard.method(&quot;showStep&quot;, function(step, callback) {
        flags.skippingStep = false;

        Arrows.clear();

        if (this.currentStep &amp;&amp; this.currentStep.listeners &amp;&amp; this.currentStep.listeners.afterStep)
            this.currentStep.listeners.afterStep();

        function skipStep(wiz) {
            flags.skippingStep = true;
            this.next();
        }

        if (step &amp;&amp; step.listeners &amp;&amp; step.listeners.beforeStep)
            step.listeners.beforeStep();

        //The shown step is, of course, the current
        this.currentStep = step;

        //If the step has a skipIf evaluator and it evaluates to true, we&#x27;ll skip to the next step!
        if (step.skipIf &amp;&amp; step.skipIf())
            skipStep(this);

        if (flags.changingStep &amp;&amp; !flags.skippingStep) {
            //Sets the current subject and updates its dimension and position
            if (step.subject)
                SS.setSubject(step.subject);
            else
                SS.setEmptySubject();
            //Updates the mask
            Mask.CompositeMask.singleInstance.update(Subject.position, Subject.dimension, Subject.borderRadius);
            var sm = Mask.SubjectMask.singleInstance;
            sm.fadeOut(function() {
                if (step.lockSubject) sm.show(true);
            });
            //The details panel (that wraps the step description and arrow) is shown
            DetailsPanel.singleInstance.show();
            //Repositionate the details panel depending on the remaining space in the screen
            DetailsPanel.singleInstance.positionate();
            //Sets the description properties (text, title and step position)
            var description = StepDescription.singleInstance;
            var text = step.text;
            text = text instanceof Function ? SS.heredoc(text) : text;
            if (step.format == &quot;markdown&quot;) {
                description.setHTML(new markdown.Converter().makeHtml(text));
            } else
                description.setText(text);

            description.setTitle(step.title);
            description.setStepPosition((this.getStepPosition() + 1) + &quot;/&quot; + this._storyline.steps.length);
            //If this step doesn&#x27;t have its own passing conditions/evaluators, or the flag &quot;showNextButton&quot; is true, then, the button is visible
            if (step.showNextButton || step.autoContinue === false || !(step.completingConditions &amp;&amp; step.completingConditions.length &gt; 0)) {
                var nextStep = this._storyline.steps[this.getStepPosition() + 1];
                if (nextStep) {
                    description.nextButton.setText(getString(strings.next) + &quot;: &quot; + this._storyline.steps[this.getStepPosition() + 1].title);
                    description.nextButton.show();
                } else {
                    description.nextButton.setText(getString(strings.finishWizard));
                    description.nextButton.show();
                }

                if (step.autoContinue === false) description.nextButton.disable();
            } else {
                description.nextButton.hide();
            }

            if (step.targets &amp;&amp; step.targets.length &gt; 0) {
                Arrows.setTargets(step.targets);
                Arrows.render();
                Arrows.positionate();
                Arrows.fadeIn();
            }

            //Step Description is shown, but is transparent yet (since we need to know its dimension to positionate it properly)
            description.show(true);
            description.positionate();
            //Do a simple fade in for the description box
            description.fadeIn();

            //If a callback is passed, call it    
            if (callback) callback();
            flags.changingStep = false;
        }
    });

    /**
    Shows the next step of the wizard

    @method next 
    @param {Function} callback                            A callback function to be called
    **/
    Wizard.method(&quot;next&quot;, function(callback, nextStep) {
        if (!flags.changingStep || flags.skippingStep) {
            flags.changingStep = true;

            nextStep = nextStep || this._storyline.steps[this.getStepPosition(this.currentStep) + 1];
            var self = this;

            this.hideStep(function() {
                if (nextStep) self.showStep(nextStep, function() {
                    if (callback) callback();
                });
                else {
                    var completedWizard = currentWizard;
                    currentWizard = null;
                    var listeners = self.listeners;
                    if (listeners &amp;&amp; listeners.afterWizardEnds) listeners.afterWizardEnds();

                    if (!SS.showRelatedWizardsList(completedWizard)) SS.close();
                }
            });
        }
    });

    /**
    Hides the step

    @method hideStep
    @param {Function} callback                            A callback function to be called in the ending of the hiding process
    **/
    Wizard.method(&quot;hideStep&quot;, function(callback) {
        StepDescription.singleInstance.fadeOut(function() {
            DetailsPanel.singleInstance.hide();
        });
        Arrows.fadeOut();
        Mask.SubjectMask.singleInstance.fadeIn(callback);
    });

    /**
    Returns the position of the step passed as argument or (by default) the current step

    @method getStepPosition
    @param {Object} step                                  The step object to get position
    **/
    Wizard.method(&quot;getStepPosition&quot;, function(step) {
        return this._storyline.steps.indexOf(step || this.currentStep);
    });

    /**
    Checks if a wizard should be shown in the current context (running each evaluator defined for this wizard)

    @method isEligible
    @return {boolean}                                     A boolean indicating if this wizard should be available in the current context
    **/
    Wizard.method(&quot;isEligible&quot;, function() {
        var l = global.location;

        function isEqual(a, b, caseSensitive) {
            return (caseSensitive) ? a === b : a.toLowerCase() === b.toLowerCase();
        }

        for (var c = 0; c &lt; this.affects.length; c++) {
            var condition = this.affects[c];
            if (condition instanceof Function) {
                if (condition()) return true;
            } else if (condition instanceof Object) {
                if (&quot;route&quot; in condition) {
                    var route = l.pathname + l.search + l.hash;
                    if (isEqual(route, condition.route, condition.caseSensitive)) return true;
                }

                if (&quot;hash&quot; in condition) {
                    if (isEqual(location.hash, condition.hash, condition.caseSensitive)) return true;
                }

                if (&quot;url&quot; in condition) {
                    if (isEqual(location.href, condition.url, condition.caseSensitive)) return true;
                }
            }
        }
        return false;
    });

    /**
    Checks if the current user already watched this wizard

    @method isAlreadyWatched
    @return {boolean}                                     A boolean indicating if the user watched this wizard
    @@todo Implement this method...
    **/
    Wizard.method(&quot;isAlreadyWatched&quot;, function() {
        //ToDo
        return false;
    });

    /**
    A Polling function to check if the current step is completed

    @method pollForCheckCompletedStep
    **/
    Wizard.method(&quot;pollForCheckCompletedStep&quot;, function() {
        var conditions = this.currentStep.completingConditions;
        if (conditions &amp;&amp; conditions.length &gt; 0 &amp;&amp; !flags.skippingStep) {
            var completed = true;
            for (var fn = 0; fn &lt; conditions.length; fn++) {
                var completingCondition = conditions[fn];
                if (!completingCondition()) completed = false;
            }

            if (completed) {
                if (this.currentStep.autoContinue === false) StepDescription.singleInstance.nextButton.enable();
                else currentWizard.next();
            }
        }
    });







    /**
    The panel that holds step description, is positionated over the biggest remaining space among the four parts of a composite mask

    @class DetailsPanel
    @@singleton
    @extends FadableItem
    **/
    var DetailsPanel = jazz.Class().extending(FadableItem).singleton;

    /**
    An object holding dimension information for the Details Panel

    @@field dimension
    @type Object
    **/
    DetailsPanel.field(&quot;dimension&quot;, {});

    /**
    An object holding positioning information for the Details Panel

    @@field position
    @type Object
    **/
    DetailsPanel.field(&quot;position&quot;, {});

    /**
    Renders the Details Panel

    @method render
    **/
    DetailsPanel.method(&quot;render&quot;, function() {
        this.$el = $(&quot;&lt;div&gt;&quot;)
            .addClass(&quot;sideshow-details-panel&quot;)
            .addClass(&quot;sideshow-hidden&quot;);
        this.callSuper(&quot;render&quot;);
    });

    /**
    Positionates the panel automatically, calculating the biggest available area and putting the panel over there

    @method positionate
    **/
    DetailsPanel.method(&quot;positionate&quot;, function() {
        var parts = Mask.CompositeMask.singleInstance.parts;

        //Considering the four parts surrounding the current subject, gets the biggest one
        var biggestSide = [
            [parts.top, &quot;height&quot;],
            [parts.right, &quot;width&quot;],
            [parts.bottom, &quot;height&quot;],
            [parts.left, &quot;width&quot;]
        ].sort(function(a, b) {
            return a[0].dimension[a[1]] &gt; b[0].dimension[b[1]];
        }).slice(-1)[0];

        if (biggestSide[1] == &quot;width&quot;) {
            this.$el
                .css(&quot;left&quot;, biggestSide[0].position.x).css(&quot;top&quot;, 0)
                .css(&quot;height&quot;, Screen.dimension.height).css(&quot;width&quot;, biggestSide[0].dimension.width);
        } else {
            this.$el
                .css(&quot;left&quot;, 0).css(&quot;top&quot;, biggestSide[0].position.y)
                .css(&quot;height&quot;, biggestSide[0].dimension.height).css(&quot;width&quot;, Screen.dimension.width);
        }

        this.dimension = {
            width: parsePxValue(this.$el.css(&quot;width&quot;)),
            height: parsePxValue(this.$el.css(&quot;height&quot;))
        };

        this.position = {
            x: parsePxValue(this.$el.css(&quot;left&quot;)),
            y: parsePxValue(this.$el.css(&quot;top&quot;))
        };
    });







    /**
    Class representing all the current shown arrows

    @class Arrows
    @static
    **/
    var Arrows = {};

    zzz = Arrows;
    Arrows.arrows = [];

    /**
    Clear the currently defined arrows

    @method clear
    @static
    **/
    Arrows.clear = function() {
        this.arrows = [];
    };

    /**
    Sets the targets for arrows to point

    @method setTargets
    @static
    **/
    Arrows.setTargets = function(targets) {
        if (targets.constructor === String) targets = $(targets);

        if (targets instanceof $ &amp;&amp; targets.length &gt; 0) {
            targets.each(function() {
                var arrow = Arrow.build();
                arrow.target.$el = $(this);
                if (arrow.target.$el.is(&quot;:visible&quot;)) {
                    Arrows.arrows.push(arrow);
                    arrow.onceVisible = true;
                }
            });
        } else {
            throw new SSException(&quot;150&quot;, &quot;Invalid targets.&quot;);
        }
    };

    Arrows.recreateDOMReferences = function() {
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            arrow.$el.remove();
        }

        Arrows.clear();
        Arrows.setTargets(currentWizard.currentStep.targets);
        Arrows.render();
        Arrows.positionate();
        Arrows.show();
    };

    /**
    Iterates over the arrows collection showing each arrow

    @method show
    @static
    **/
    Arrows.show = function() {
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            arrow.show();
        }
    };

    /**
    Iterates over the arrows collection hiding each arrow

    @method hide
    @static
    **/
    Arrows.hide = function() {
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            arrow.hide();
        }
    };

    /**
    Iterates over the arrows collection fading in each arrow

    @method fadeIn
    @static
    **/
    Arrows.fadeIn = function() {
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            arrow.fadeIn();
        }
    };

    /**
    Iterates over the arrows collection fading out each arrow

    @method fadeOut
    @static
    **/
    Arrows.fadeOut = function() {
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            registerFadeOut(arrow);
        }

        function registerFadeOut(arrow) {
            arrow.fadeOut(function() {
                arrow.destroy();
            });
        }
    };

    /**
    Iterates over the arrows collection repositionating each arrow

    @method positionate
    @static
    **/
    Arrows.positionate = function() {
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            arrow.positionate();
        }
    };

    /**
    Iterates over the arrows collection rendering each arrow

    @method render
    @static
    **/
    Arrows.render = function() {
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            arrow.render();
        }
    };

    /**
    A Polling function to check if arrows coordinates has changed

    @method pollForArrowsChanges
    **/
    Arrows.pollForArrowsChanges = function() {
        var brokenReference = false;
        for (var a = 0; a &lt; this.arrows.length; a++) {
            var arrow = this.arrows[a];
            if (arrow.hasChanged()) arrow.positionate();
            if (arrow.onceVisible &amp;&amp; !arrow.target.$el.is(&quot;:visible&quot;)) brokenReference = true;
        }

        if (brokenReference) this.recreateDOMReferences();
    };







    /**
    A single arrow for pointing individual items in current subject 

    @class Arrow
    **/
    var Arrow = jazz.Class().extending(FadableItem);

    /**
    The jQuery wrapped object which will be pointed by this arrow

    @@field target
    @type Object
    **/
    Arrow.field(&quot;target&quot;, {});

    /**
    Flag created to set if the arrow was visible once, this is used for recreating references to the targets DOM objects

    @@field onceVisible
    @type Object
    **/
    Arrow.field(&quot;onceVisible&quot;, false);

    /**
    Renders the Arrow

    @method render
    **/
    Arrow.method(&quot;render&quot;, function() {
        this.$el = $(&quot;&lt;div&gt;&quot;)
            .addClass(&quot;sideshow-subject-arrow&quot;)
            .addClass(&quot;sideshow-hidden&quot;)
            .addClass(&quot;sideshow-invisible&quot;);
        this.callSuper(&quot;render&quot;);
    });

    /**
    Positionates the Arrow according to its target

    @method positionate
    **/
    Arrow.method(&quot;positionate&quot;, function() {
        var target = this.target;
        target.position = {
            x: target.$el.offset().left,
            y: target.$el.offset().top
        };
        target.dimension = {
            width: target.$el.outerWidth(),
            height: target.$el.outerHeight()
        };

        this.$el.css(&quot;top&quot;, target.position.y - 30 + &quot;px&quot;)
            .css(&quot;left&quot;, target.position.x + (parsePxValue(target.dimension.width) / 2) - 12 + &quot;px&quot;);
    });

    /**
    Shows the Arrow 

    @method show
    **/
    Arrow.method(&quot;show&quot;, function() {
        this.callSuper(&quot;show&quot;);
        this.positionate();
    });

    /**
    Does a fade in transition in the Arrow 

    @method fadeIn
    **/
    Arrow.method(&quot;fadeIn&quot;, function() {
        this.callSuper(&quot;fadeIn&quot;);
        this.positionate();
    });

    /**
    Checks if the arrow&#x27;s target position or dimension has changed

    @method hasChanged
    @return boolean                                     
    **/
    Arrow.method(&quot;hasChanged&quot;, function() {
        return (this.target.dimension.width !== this.target.$el.outerWidth() ||
            this.target.dimension.height !== this.target.$el.outerHeight() ||
            this.target.position.y !== this.target.$el.offset().top ||
            this.target.position.x !== this.target.$el.offset().left);
    });





    /**
    Represents a panel holding the step description

    @class StepDescription
    @extends FadableItem
    @@initializer
    **/
    var StepDescription = jazz.Class(function() {
        this.nextButton = StepDescriptionNextButton.build();
    }).extending(FadableItem).singleton;

    /**
    The step description text content

    @@field text
    @type String
    **/
    StepDescription.field(&quot;text&quot;, &quot;&quot;);

    /**
    The title text for the step description panel

    @@field title
    @type String
    **/
    StepDescription.field(&quot;title&quot;, &quot;&quot;);

    /**
    An object holding dimension information for the Step Description panel

    @@field dimension
    @type Object
    **/
    StepDescription.field(&quot;dimension&quot;, {});

    /**
    An object holding positioning information for the Step Description panel

    @@field position
    @type Object
    **/
    StepDescription.field(&quot;position&quot;, {});

    /**
    An object representing the next button for a step description panel 

    @@field nextButton
    @type Object
    **/
    StepDescription.field(&quot;nextButton&quot;);

    /**
    Sets the text for the step description panel

    @method setText
    @param {String} text                                  The text for the step description panel
    **/
    StepDescription.method(&quot;setText&quot;, function(text) {
        this.text = text;
        this.$el.find(&quot;.sideshow-step-text&quot;).text(text);
    });

    /**
    Sets the HTML content for the step description panel

    @method setHTML
    @param {String} text                                  The HTML content for step description panel
    **/
    StepDescription.method(&quot;setHTML&quot;, function(text) {
        this.text = text;
        this.$el.find(&quot;.sideshow-step-text&quot;).html(text);
    });

    /**
    Sets the title for the step description panel

    @method setTitle
    @param {String} title                                 The text for the step description panel
    **/
    StepDescription.method(&quot;setTitle&quot;, function(title) {
        this.title = title;
        this.$el.find(&quot;h2&quot;).text(title);
    });

    /**
    Sets the title for the step description panel

    @method setStepPosition
    @param {String} title                                 The text for the step description panel
    **/
    StepDescription.method(&quot;setStepPosition&quot;, function(stepPosition) {
        this.stepPosition = stepPosition;
        this.$el.find(&quot;.sideshow-step-position&quot;).text(stepPosition);
    });

    /**
    Renders the step description panel

    @method render
    **/
    StepDescription.method(&quot;render&quot;, function() {
        this.$el = $(&quot;&lt;div&gt;&quot;)
            .addClass(&quot;sideshow-step-description&quot;)
            .addClass(&quot;sideshow-hidden&quot;)
            .addClass(&quot;sideshow-invisible&quot;);

        var stepPosition = $(&quot;&lt;span&gt;&quot;).addClass(&quot;sideshow-step-position&quot;);
        this.$el.append(stepPosition);
        if (currentWizard.showStepPosition === false) stepPosition.hide();

        this.$el.append($(&quot;&lt;h2&gt;&quot;));
        this.$el.append($(&quot;&lt;div&gt;&quot;).addClass(&quot;sideshow-step-text&quot;));
        this.nextButton.render(this.$el);
        this.nextButton.$el.click(function() {
            currentWizard.next();
        });
        DetailsPanel.singleInstance.$el.append(this.$el);
    });

    /**
    Shows the step description panel

    @method show
    **/
    StepDescription.method(&quot;show&quot;, function() {
        this.callSuper(&quot;show&quot;);
        this.positionate();
    });

    /**
    Positionates the step description panel

    @method positionate
    **/
    StepDescription.method(&quot;positionate&quot;, function() {
        var dp = DetailsPanel.singleInstance;

        if (dp.dimension.width &gt;= 900)
            this.dimension.width = 900;
        else if (dp.dimension.width &lt;= 500)
            this.dimension.width = 500;
        else
            this.dimension.width = dp.dimension.width * 0.9;

        this.$el.css(&quot;width&quot;, this.dimension.width);

        this.dimension.height = parsePxValue(this.$el.outerHeight());

        //Checks if the description dimension overflow the available space in the details panel
        if (this.dimension.height &gt; dp.dimension.height || this.dimension.width &gt; dp.dimension.width) {
            this.position.x = (Subject.dimension.width - this.dimension.width) / 2;
            this.position.y = (Subject.dimension.height - this.dimension.height) / 2;
        } else {
            this.position.x = (dp.dimension.width - this.dimension.width) / 2;
            this.position.y = (dp.dimension.height - this.dimension.height) / 2;
        }

        this.$el.css(&quot;left&quot;, this.position.x);
        this.$el.css(&quot;top&quot;, this.position.y);
    });







    /**
    Step next button 

    @class StepDescriptionNextButton
    @extends HidableItem
    **/
    var StepDescriptionNextButton = jazz.Class().extending(HidableItem);

    /**
    The text for the next button

    @@field _text
    @private
    **/
    StepDescriptionNextButton.field(&quot;_text&quot;);

    /**
    Disables the next button

    @method disable
    **/
    StepDescriptionNextButton.method(&quot;disable&quot;, function() {
        this.$el.attr(&quot;disabled&quot;, &quot;disabled&quot;);
    });

    /**
    Enables the next button

    @method enable
    **/
    StepDescriptionNextButton.method(&quot;enable&quot;, function() {
        this.$el.attr(&quot;disabled&quot;, null);
    });

    /**
    Sets the text for the next button

    @method setText
    @param {String} text                                  The text for the next button
    **/
    StepDescriptionNextButton.method(&quot;setText&quot;, function(text) {
        this._text = text;
        this.$el.text(text);
    });

    /**
    Renders the Next Button

    @method render
    @param {Object} $stepDescriptionEl                    The jQuery wrapped DOM element for the Step Description panel
    **/
    StepDescriptionNextButton.method(&quot;render&quot;, function($stepDescriptionEl) {
        this.$el = $(&quot;&lt;button&gt;&quot;).addClass(&quot;sideshow-next-step-button&quot;);
        this.callSuper(&quot;render&quot;, $stepDescriptionEl);
    });







    /**
    Represents the current available area in the browser

    @class Screen
    @static
    **/
    var Screen = {};

    /**
    Object holding dimension information for the screen

    @@field
    @static
    @type Object
    **/
    Screen.dimension = {};

    /**
    Checks if the screen dimension information has changed

    @method hasChanged
    @static
    @return boolean
    **/
    Screen.hasChanged = function() {
        return ($body.outerWidth() !== this.dimension.width) ||
            ($body.outerHeight() !== this.dimension.height);
    };

    /**
    Updates the dimension information for the screen 

    @method updateInfo
    @static
    **/
    Screen.updateInfo = function() {
        this.dimension.width = $body.outerWidth();
        this.dimension.height = $body.outerHeight();
    };







    /**
    The current subject (the object being shown by the current wizard)

    @class Subject
    @static
    **/
    var Subject = {};

    /**
    The current subject jQuery wrapped DOM element 

    @@field obj
    @static
    @type Object
    **/
    Subject.obj = null;

    /**
    The current subject dimension information

    @@field position
    @static
    @type Object
    **/
    Subject.dimension = {};

    /**
    The current subject positioning information

    @@field position
    @static
    @type Object
    **/
    Subject.position = {};

    /**
    The current subject border radius information

    @@field borderRadius
    @static
    @type Object
    **/
    Subject.borderRadius = {};

    /**
    Checks if the object has changed since the last checking

    @method hasChanged
    @return boolean
    **/
    Subject.hasChanged = function() {
        if (!this.obj) return false;

        return (this.obj.offset().left !== this.position.x) ||
            (this.obj.offset().top !== this.position.y) ||
            (this.obj.outerWidth() !== this.dimension.width) ||
            (this.obj.outerHeight() !== this.dimension.height) ||
            (parsePxValue(this.obj.css(&quot;border-top-left-radius&quot;)) !== this.borderRadius.leftTop) ||
            (parsePxValue(this.obj.css(&quot;border-top-right-radius&quot;)) !== this.borderRadius.rightTop) ||
            (parsePxValue(this.obj.css(&quot;border-bottom-left-radius&quot;)) !== this.borderRadius.leftBottom) ||
            (parsePxValue(this.obj.css(&quot;border-bottom-right-radius&quot;)) !== this.borderRadius.rightBottom) ||
            Screen.hasChanged();
    };

    /**
    Updates the information about the suject

    @method updateInfo
    @param {Object} config                                Dimension, positioning and border radius information
    **/
    Subject.updateInfo = function(config) {
        if (config === undefined) {
            this.position.x = this.obj.offset().left;
            this.position.y = this.obj.offset().top;
            this.dimension.width = this.obj.outerWidth();
            this.dimension.height = this.obj.outerHeight();
            this.borderRadius.leftTop = parsePxValue(this.obj.css(&quot;border-top-left-radius&quot;));
            this.borderRadius.rightTop = parsePxValue(this.obj.css(&quot;border-top-right-radius&quot;));
            this.borderRadius.leftBottom = parsePxValue(this.obj.css(&quot;border-bottom-left-radius&quot;));
            this.borderRadius.rightBottom = parsePxValue(this.obj.css(&quot;border-bottom-right-radius&quot;));
        } else {
            this.position.x = config.position.x;
            this.position.y = config.position.y;
            this.dimension.width = config.dimension.width;
            this.dimension.height = config.dimension.height;
            this.borderRadius.leftTop = config.borderRadius.leftTop;
            this.borderRadius.rightTop = config.borderRadius.rightTop;
            this.borderRadius.leftBottom = config.borderRadius.leftBottom;
            this.borderRadius.rightBottom = config.borderRadius.rightBottom;
        }

        Screen.updateInfo();
    };







    /**
    Namespace to hold classes for mask control

    @namespace Mask
    **/
    var Mask = {};

    /**
    Controls the mask that covers the subject during a step transition

    @class SubjectMask
    @@singleton
    **/
    Mask.SubjectMask = jazz.Class().extending(FadableItem).singleton;

    /**
    Renders the subject mask

    @method render
    **/
    Mask.SubjectMask.method(&quot;render&quot;, function() {
        this.$el = $(&quot;&lt;div&gt;&quot;).addClass(&quot;sideshow-subject-mask&quot;);
        this.callSuper(&quot;render&quot;);
    });

    /**
    Updates the dimension, positioning and border radius of the subject mask

    @method update
    @param {Object} position                              The positioning information 
    @param {Object} dimension                             The dimension information 
    @param {Object} borderRadius                          The border radius information 
    **/
    Mask.SubjectMask.method(&quot;update&quot;, function(position, dimension, borderRadius) {
        this.$el
            .css(&quot;left&quot;, position.x)
            .css(&quot;top&quot;, position.y)
            .css(&quot;width&quot;, dimension.width)
            .css(&quot;height&quot;, dimension.height)
            .css(&quot;border-radius&quot;, borderRadius.leftTop + &quot;px &quot; + borderRadius.rightTop + &quot;px &quot; + borderRadius.leftBottom + &quot;px &quot; + borderRadius.rightBottom + &quot;px &quot;);
    });







    /**
    Controls the mask surrounds the subject (the step focussed area)

    @class CompositeMask
    @@singleton
    **/
    Mask.CompositeMask = jazz.Class().extending(FadableItem).singleton;

    /**
    Initializes the composite mask

    @method init
    **/
    Mask.CompositeMask.method(&quot;init&quot;, function() {
        var mask = this;
        [&quot;top&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottom&quot;].forEach(function(d) {
            mask.parts[d] = Mask.CompositeMask.Part.build();
        });
        [&quot;leftTop&quot;, &quot;rightTop&quot;, &quot;leftBottom&quot;, &quot;rightBottom&quot;].forEach(function(d) {
            mask.parts[d] = Mask.CompositeMask.CornerPart.build();
        });
    });

    /**
    The parts composing the mask

    @@field parts
    @type Object
    **/
    Mask.CompositeMask.field(&quot;parts&quot;, {});

    /**
    Renders the composite mask 

    @method render
    **/
    Mask.CompositeMask.method(&quot;render&quot;, function() {
        var mask = this;
        for (var p in this.parts) {
            var part = this.parts[p];
            if (part.render) part.render();
        }
        this.$el = $(&quot;.sideshow-mask-part, .sideshow-mask-corner-part&quot;);
        // if(!this.$el || this.$el.length === 0) this.$el = $(&quot;.sideshow-mask-part, .sideshow-mask-corner-part&quot;);
        Mask.SubjectMask.singleInstance.render();
        [&quot;leftTop&quot;, &quot;rightTop&quot;, &quot;leftBottom&quot;, &quot;rightBottom&quot;].forEach(function(d) {
            mask.parts[d].$el.addClass(d);
        });
        this.status = AnimationStatus.NOT_DISPLAYED;
    });

    /**
    Updates the positioning and dimension of each part composing the whole mask, according to the subject coordinates

    @method update
    @param {Object} position                              An object representing the positioning info for the mask
    @param {Object} dimension                             An object representing the dimension info for the mask
    @param {Object} borderRadius                          An object representing the borderRadius info for the mask
    **/
    Mask.CompositeMask.method(&quot;update&quot;, function(position, dimension, borderRadius) {
        Mask.SubjectMask.singleInstance.update(position, dimension, borderRadius);

        //Aliases
        var left = position.x,
            top = position.y,
            width = dimension.width,
            height = dimension.height,
            br = borderRadius;

        //Updates the divs surrounding the subject
        this.parts.top.update({
            x: 0,
            y: 0
        }, {
            width: $body.width(),
            height: top
        });
        this.parts.left.update({
            x: 0,
            y: top
        }, {
            width: left,
            height: height
        });
        this.parts.right.update({
            x: left + width,
            y: top
        }, {
            width: $body.width() - (left + width),
            height: height
        });
        this.parts.bottom.update({
            x: 0,
            y: top + height
        }, {
            width: $body.width(),
            height: $body.height() - (top + height)
        });

        //Updates the Rounded corners
        this.parts.leftTop.update({
            x: left,
            y: top
        }, br.leftTop);
        this.parts.rightTop.update({
            x: left + width - br.rightTop,
            y: top
        }, br.rightTop);
        this.parts.leftBottom.update({
            x: left,
            y: top + height - br.leftBottom
        }, br.leftBottom);
        this.parts.rightBottom.update({
            x: left + width - br.rightBottom,
            y: top + height - br.rightBottom
        }, br.rightBottom);
    });

    /**
    A Polling function to check if subject coordinates has changed

    @method pollForChanges
    **/
    Mask.CompositeMask.method(&quot;pollForChanges&quot;, function() {
        if (!flags.lockMaskUpdate) {
            if (currentWizard &amp;&amp; currentWizard.currentStep.subject) {
                var subject = $(currentWizard.currentStep.subject);
                if (Subject.obj[0] !== subject[0]) SS.setSubject(subject);
            }

            if (Subject.hasChanged()) {
                Subject.updateInfo();
                this.update(Subject.position, Subject.dimension, Subject.borderRadius);
            }
        }

        if (Screen.hasChanged()) {
            Screen.updateInfo();
            this.update(Subject.position, Subject.dimension, Subject.borderRadius);
        }
    });

    /**
    A part composing the mask

    @class Part
    @@initializer 
    @param {Object} position                              The positioning information 
    @param {Object} dimension                             The dimension information 
    **/
    Mask.CompositeMask.Part = jazz.Class(function(position, dimension) {
        this.position = position;
        this.dimension = dimension;
    }).extending(VisualItem);







    /**
    @@alias Part
    @@to Mask.CompositeMask.Part
    **/
    var Part = Mask.CompositeMask.Part;

    /**
    An object holding positioning information for the mask part

    @@field position
    @type Object
    **/
    Part.field(&quot;position&quot;, {});

    /**
    An object holding dimension information for the mask part

    @@field position
    @type Object
    **/
    Part.field(&quot;dimension&quot;, {});

    /**
    Renders the mask part

    @method render
    **/
    Part.method(&quot;render&quot;, function() {
        this.$el = $(&quot;&lt;div&gt;&quot;)
            .addClass(&quot;sideshow-mask-part&quot;)
            .addClass(&quot;sideshow-hidden&quot;)
            .addClass(&quot;sideshow-invisible&quot;);
        this.callSuper(&quot;render&quot;);
    });

    /**
    Updates the dimension and positioning of the subject mask part

    @method update
    @param {Object} position                              The positioning information 
    @param {Object} dimension                             The dimension information 
    **/
    Part.method(&quot;update&quot;, function(position, dimension) {
        this.position = position;
        this.dimension = dimension;
        this.$el
            .css(&quot;left&quot;, position.x)
            .css(&quot;top&quot;, position.y)
            .css(&quot;width&quot;, dimension.width)
            .css(&quot;height&quot;, dimension.height);
    });







    /**
    A corner part composing the mask

    @class CornerPart
    @@initializer 
    @param {Object} position                              The positioning information 
    @param {Object} dimension                             The dimension information 
    **/
    Mask.CompositeMask.CornerPart = jazz.Class().extending(VisualItem);

    /**
    @@alias CornerPart
    @@to Mask.CompositeMask.CornerPart
    **/
    var CornerPart = Mask.CompositeMask.CornerPart;

    /**
    An object holding positioning information for the mask corner part

    @@field position
    @type Object
    **/
    CornerPart.field(&quot;position&quot;, {});

    /**
    An object holding dimension information for the mask corner part

    @@field position
    @type Object
    **/
    CornerPart.field(&quot;dimension&quot;, {});

    /**
    An object holding border radius information for the mask corner part

    @@field borderRadius
    @type Object
    **/
    CornerPart.field(&quot;borderRadius&quot;, 0);

    /**
    Formats the SVG path for the corner part

    @method SVGPathPointsTemplate
    @param {Number} borderRadius                          The corner part border radius
    @static
    **/
    CornerPart.static.SVGPathPointsTemplate = function(borderRadius) {
        return &quot;m 0,0 0,&quot; + borderRadius + &quot; C 0,&quot; + borderRadius * 0.46 + &quot; &quot; + borderRadius * 0.46 + &quot;,0 &quot; + borderRadius + &quot;,0&quot;;
    };

    /**
    Renders the SVG for the corner part

    @method buildSVG
    @param {Number} borderRadius                          The corner part border radius
    @static
    **/
    CornerPart.static.buildSVG = function(borderRadius) {
        function SVG(nodeName) {
            return document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, nodeName);
        }

        var bezierPoints = this.SVGPathPointsTemplate(borderRadius);
        var $svg = $(SVG(&quot;svg&quot;));
        var $path = $(SVG(&quot;path&quot;));

        $path.attr(&quot;d&quot;, bezierPoints);
        $svg.append($path);

        return $svg[0];
    };

    /**
    Renders the mask corner part

    @method render
    @return {Object}                                      The corner part jQuery wrapped DOM element
    **/
    CornerPart.prototype.render = function() {
        this.$el = $(&quot;&lt;div&gt;&quot;)
            .addClass(&quot;sideshow-mask-corner-part&quot;)
            .addClass(&quot;sideshow-hidden&quot;)
            .addClass(&quot;sideshow-invisible&quot;);
        this.$el.append(CornerPart.buildSVG(this.borderRadius));
        $body.append(this.$el);
        return this.$el;
    };

    /**
    Updates the positioning and border radius of the mask corner part

    @method update
    @param {Object} position                              The positioning information 
    @param {Object} borderRadius                          The border radius information 
    **/
    CornerPart.prototype.update = function(position, borderRadius) {
        this.$el
            .css(&quot;left&quot;, position.x)
            .css(&quot;top&quot;, position.y)
            .css(&quot;width&quot;, borderRadius)
            .css(&quot;height&quot;, borderRadius);

        $(this.$el).find(&quot;path&quot;).attr(&quot;d&quot;, CornerPart.SVGPathPointsTemplate(borderRadius));
    };







    /**
    Controls the polling functions needed by Sideshow

    @class Polling
    @static
    **/
    var Polling = {};

    /**
    The polling functions queue

    @@field queue
    @type Object
    @static
    **/
    Polling.queue = [];

    /**
    A flag that controls if the polling is locked

    @@field lock
    @type boolean
    @static
    **/
    Polling.lock = false;

    /**
    Pushes a polling function in the queue

    @method enqueue
    @param {Function} fn                                  The polling function to enqueue
    @static
    **/
    Polling.enqueue = function(fn) {
        if (this.queue.indexOf(fn) &lt; 0) {
            this.queue.push(fn);
        } else
            throw new SSException(&quot;301&quot;, &quot;The function is already in the polling queue.&quot;);
    };

    /**
    Removes a polling function from the queue

    @method dequeue
    @param {Function} fn                                  The polling function to dequeue
    @static
    **/
    Polling.dequeue = function(fn) {
        this.queue.splice(this.queue.indexOf(fn), 1);
    };

    /**
    Unlocks the polling and starts the checking process

    @method start
    @static
    **/
    Polling.start = function() {
        this.lock = false;
        this.doPolling();
    };

    /**
    Stops the polling process

    @method stop
    @static
    **/
    Polling.stop = function() {
        this.lock = true;
    };

    /**
    Clear the polling queue

    @method clear
    @static
    **/
    Polling.clear = function() {
        var lock = this.lock;

        this.lock = true;
        this.queue = [];
        this.lock = lock;
    };

    /**
    Starts the polling process  

    @method doPolling
    @static
    **/
    Polling.doPolling = function() {
        if (!this.lock) {
            //Using timeout to avoid the queue to not complete in a cycle
            setTimeout(function() {
                for (var fn = 0; fn &lt; Polling.queue.length; fn++) {
                    var pollingFunction = Polling.queue[fn];
                    pollingFunction();
                }
                Polling.doPolling();
            }, pollingDuration);
        }
    };







    /**
    The main menu, where the available wizards are listed

    @class WizardMenu
    @static
    **/
    var WizardMenu = {};

    /**
    Renders the wizard menu

    @method render
    @param {Array} wizards                                The wizards list
    @static
    **/
    WizardMenu.render = function(wizards) {
        var $menu = $(&quot;&lt;div&gt;&quot;).addClass(&quot;sideshow-wizard-menu&quot;);
        this.$el = $menu;
        var $title = $(&quot;&lt;h1&gt;&quot;).addClass(&quot;sideshow-wizard-menu-title&quot;);
        $menu.append($title);

        if (wizards.length &gt; 0) {
            var $wizardsList = $(&quot;&lt;ul&gt;&quot;);

            //Extracting this function to avoid the JSHint warning W083
            function setClick($wiz, wizard) {
                $wiz.click(function() {
                    WizardMenu.hide(function() {
                        currentWizard = wizard;
                        if (!currentWizard.isEligible()) {
                            if (currentWizard.preparation)
                                currentWizard.preparation(function() {
                                    wizard.play();
                                });
                            else
                                throw new SSException(&quot;203&quot;, &quot;This wizard is not eligible neither has a preparation function.&quot;);
                        } else wizard.play();
                    });
                });
            }

            for (var w = 0; w &lt; wizards.length; w++) {
                var wiz = wizards[w];
                var $wiz = $(&quot;&lt;li&gt;&quot;);
                var $wizTitle = $(&quot;&lt;h2&gt;&quot;).text(wiz.title);
                var $wizDescription = $(&quot;&lt;span&gt;&quot;).addClass(&quot;sideshow-wizard-menu-item-description&quot;).text(wiz.description);
                var $wizEstimatedTime = $(&quot;&lt;span&gt;&quot;).addClass(&quot;sideshow-wizard-menu-item-estimated-time&quot;).text(wiz.estimatedTime);
                $wiz.append($wizEstimatedTime, $wizTitle, $wizDescription);
                $wizardsList.append($wiz);

                setClick($wiz, wiz);
            }
            $menu.append($wizardsList);
        } else {
            $(&quot;&lt;div&gt;&quot;).addClass(&quot;sideshow-no-wizards-available&quot;).text(getString(strings.noAvailableWizards)).appendTo($menu);
        }

        $body.append($menu);
    };

    /**
    Shows the wizard menu

    @method show
    @param {Array} wizards                                The wizards list
    @static
    **/
    WizardMenu.show = function(wizards, title) {
        SS.setEmptySubject();
        Mask.CompositeMask.singleInstance.update(Subject.position, Subject.dimension, Subject.borderRadius);
        Mask.CompositeMask.singleInstance.fadeIn();
        WizardMenu.render(wizards);

        if (title)
            this.setTitle(title);
        else
            this.setTitle(getString(strings.availableWizards));
    };

    /**
    Hides the wizard menu

    @method hide
    @param {Function} callback                            The callback to be called after hiding the menu
    @static
    **/
    WizardMenu.hide = function(callback) {
        var menu = this;
        menu.$el.addClass(&quot;sideshow-menu-closed&quot;);
        setTimeout(function() {
            menu.$el.hide();
            if (callback) callback();
        }, longAnimationDuration);
    };

    WizardMenu.setTitle = function(title) {
        this.$el.find(&quot;.sideshow-wizard-menu-title&quot;).text(title);
    };





    /**
    Registers hotkeys to be used when running Sideshow

    @@function registerInnerHotkeys
    **/
    function registerInnerHotkeys() {
        $(document).keyup(innerHotkeysListener);
    }

    /**
    Unregisters hotkeys used when running Sideshow

    @@function Unregisters
    **/
    function unregisterInnerHotkeys() {
        $(document).unbind(&quot;keyup&quot;, innerHotkeysListener);
    }

    function innerHotkeysListener(e) {
        //Esc or F1
        if (e.keyCode == 27 || e.keyCode == 112) SS.close();
    }

    /**
    Registers global hotkeys

    @@function registerGlobalHotkeys
    **/
    function registerGlobalHotkeys() {
        $(document).keyup(function(e) {
            //F2
            if (e.keyCode == 113) {
                if (e.shiftKey) SS.start({
                    listAll: true
                });
                else SS.start();
            }
        });
    }






    /**
    Removes nodes created by Sideshow (except mask, which remains due to performance reasons when recalling Sideshow)

    @@function removeDOMGarbage
    **/
    function removeDOMGarbage() {
        $(&quot;[class*=\&quot;sideshow\&quot;]&quot;).not(&quot;.sideshow-mask-part, .sideshow-mask-corner-part, .sideshow-subject-mask&quot;).remove();
    }

    /**
    Initializes Sideshow

    @method init
    @static
    **/
    SS.init = function() {
        $body = $(&quot;body&quot;, global.document);
        registerGlobalHotkeys();
        Polling.start();
        Mask.CompositeMask.singleInstance.init();
        flags.lockMaskUpdate = true;
        Mask.CompositeMask.singleInstance.render();
    };

    /**
    Receives a function with just a multiline comment as body and converts to a here-document string

    @method heredoc
    @param {Function}                                     A function without body but a multiline comment
    @return {String}                                      A multiline string
    @static
    **/
    SS.heredoc = function(fn) {
        return fn.toString().match(/[^]*\/\*([^]*)\*\/\}$/)[1];
    }

    /**
    Stops and Closes Sideshow

    @method closes
    @static
    **/
    SS.close = function() {
        if (!currentWizard) WizardMenu.hide();

        DetailsPanel.singleInstance.fadeOut();

        this.CloseButton.singleInstance.fadeOut();
        Arrows.fadeOut();

        setTimeout(function() {
            if (Mask.CompositeMask.singleInstance.status === AnimationStatus.VISIBLE ||
                Mask.CompositeMask.singleInstance.status === AnimationStatus.FADING_IN)
                Mask.CompositeMask.singleInstance.fadeOut();

            Mask.SubjectMask.singleInstance.fadeOut();

        }, longAnimationDuration);

        removeDOMGarbage();
        Polling.clear();
        SS.ControlVariables.clear();
        unregisterInnerHotkeys();
        currentWizard = null;
        flags.running = false;
    };

    SS.runWizard = function(name) {
        var wiz = wizards.filter(function(w) {
            return w.name === name
        })[0];
        currentWizard = wiz;
        if (wiz) {
            if (wiz.isEligible()) wiz.play();
            else if (wiz.preparation) wiz.preparation(function() {
                setTimeout(function() {
                    wiz.play();
                }, 1000);
            });
            else throw new SSException(&quot;204&quot;, &quot;This wizard hasn&#x27;t preparation.&quot;);
        } else throw new SSException(&quot;204&quot;, &quot;There&#x27;s no wizard with name &quot; + name + &quot;.&quot;);
    };

    SS.gotoStep = function() {
        var firstArg = arguments[0],
            steps = currentWizard._storyline.steps,
            destination;

        flags.skippingStep = true;

        //First argument is the step position (1-based)
        if (typeof firstArg == &quot;number&quot;) {
            if (firstArg &lt;= steps.length)
                destination = steps[firstArg - 1];
            else
                throw new SSException(&quot;401&quot;, &quot;There&#x27;s no step in the storyline with position &quot; + firstArg + &quot;.&quot;);
        } //First argument is the step name
        else if (typeof firstArg == &quot;string&quot;) {
            destination = steps.filter(function(i) {
                return i.name === firstArg;
            })[0];

            if (!destination) throw new SSException(&quot;401&quot;, &quot;There&#x27;s no step in the storyline with name &quot; + firstArg + &quot;.&quot;);
        }
        setTimeout(function() {
            currentWizard.next(null, destination);
        }, 100);
    };

    /**
    A trick to use the composite mask to simulate the behavior of a solid mask, setting an empty subject

    @method setEmptySubject
    @static
    **/
    SS.setEmptySubject = function() {
        flags.lockMaskUpdate = true;
        Subject.obj = null;
        Subject.updateInfo({
            dimension: {
                width: 0,
                height: 0
            },
            position: {
                x: 0,
                y: 0
            },
            borderRadius: {
                leftTop: 0,
                rightTop: 0,
                leftBottom: 0,
                rightBottom: 0
            }
        });
    };

    /**
    Sets the current subject

    @method setSubject
    @param {Object} subj
    @static
    **/
    SS.setSubject = function(subj) {
        if (subj.constructor === String) subj = $(subj);

        if (subj instanceof $ &amp;&amp; subj.length &gt; 0) {
            if (subj.length === 1) {
                Subject.obj = subj;
                Subject.updateInfo();
            } else
                throw new SSException(&quot;101&quot;, &quot;A subject must have only one element. Multiple elements by step will be supported in future versions of Sideshow.&quot;);
        } else {
            throw new SSException(&quot;100&quot;, &quot;Invalid subject.&quot;);
        }
    };

    /**
    Registers a wizard

    @method registerWizard
    @param {Object} wizardConfig                          
    @return {Object}                                      The wizard instance
    @static
    **/
    SS.registerWizard = function(wizardConfig) {
        var wiz = Wizard.build(wizardConfig);
        wizards.push(wiz);
        return wiz;
    };

    /**
    Registers a wizard

    @method registerWizard
    @param {boolean} onlyNew                              Checks only recently added wizards
    @return {Array}                                       The eligible wizards list
    @static
    **/
    SS.getElegibleWizards = function getElegibleWizards(onlyNew) {
        var eligibleWizards = [];
        var somethingNew = false;
        for (var w = 0; w &lt; wizards.length; w++) {
            var wiz = wizards[w];
            if (wiz.isEligible()) {
                if (!wiz.isAlreadyWatched()) somethingNew = true;
                eligibleWizards.push(wiz);
            }
        }

        return !onlyNew || somethingNew ? eligibleWizards : [];
    };

    /**
    Checks if there are eligible wizards, if exists, shows the wizard menu   

    @method showWizardsList
    @param {boolean} onlyNew                              Checks only recently added wizards
    @return {boolean}                                     Returns a boolean indicating whether there is some wizard available
    @static
    **/
    SS.showWizardsList = function() {
        var firstArg = arguments[0];
        var title = arguments[1];
        var onlyNew = typeof firstArg == &quot;boolean&quot; ? false : firstArg;
        var wizards = firstArg instanceof Array ? firstArg : this.getElegibleWizards(onlyNew);

        WizardMenu.show(wizards, title);

        return wizards.length &gt; 0;
    };

    /**
    Shows a list with the related wizards  

    @method showRelatedWizardsList
    @param {Object} completedWizard                       The recently completed wizard
    @return {boolean}                                     Returns a boolean indicating whether there is some related wizard available
    @static
    **/
    SS.showRelatedWizardsList = function(completedWizard) {
        var relatedWizardsNames = completedWizard.relatedWizards;
        if (!relatedWizardsNames) return false;

        //Gets only related tutorials which are eligible or have a preparation function
        var relatedWizards = wizards.filter(function(w) {
            return relatedWizardsNames.indexOf(w.name) &gt; -1 &amp;&amp; (w.isEligible() || w.preparation);
        });
        if (relatedWizards.length == 0) return false;

        Polling.clear();
        SS.ControlVariables.clear();
        SS.showWizardsList(relatedWizards, getString(strings.relatedWizards));

        return true;
    };

    /**
    The close button for the wizard

    @class CloseButton
    @@singleton
    @extends FadableItem
    **/
    SS.CloseButton = jazz.Class().extending(FadableItem).singleton;

    /**
    Renders the close button

    @method render
    **/
    SS.CloseButton.method(&quot;render&quot;, function() {
        this.$el = $(&quot;&lt;button&gt;&quot;)
            .addClass(&quot;sideshow-close-button&quot;)
            .text(getString(strings.close));
        this.$el.click(function() {
            SS.close();
        });
        this.callSuper(&quot;render&quot;);
    });

    /**
    Starts Sideshow

    @method start
    @param {Object} config                                The config object for Sideshow
    **/
    SS.start = function(config) {
        config = config || {};
        if (!flags.running) {
            var onlyNew = &quot;onlyNew&quot; in config &amp;&amp; !! config.onlyNew;
            var listAll = &quot;listAll&quot; in config &amp;&amp; !! config.listAll;

            if (listAll)
                SS.showWizardsList(wizards.filter(function(w) {
                    return w.isEligible() || w.preparation;
                }));
            else
                SS.showWizardsList(onlyNew);

            this.CloseButton.singleInstance.render();
            this.CloseButton.singleInstance.fadeIn();

            registerInnerHotkeys();
            flags.running = true;
        }
    };



    //Tries to register the Global Access Point
    if (global[globalObjectName] === undefined) {
        global[globalObjectName] = SS;
    } else
        throw new SSException(&quot;1&quot;, &quot;The global access point \&quot;Sideshow\&quot; is already being used.&quot;);
})(window, jQuery, Jazz, Markdown);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
